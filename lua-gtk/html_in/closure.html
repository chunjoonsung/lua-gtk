<%= html_header("Reference") %>

<h2>Closures</h2>

<h3>Technical Background</h3>

<p>
In order to let library code call Lua functions, there are two mechanisms:
one is to use the connect function to install signal handlers; this is
handled separately.
</p>

<p>
Some library functions need to call Lua functions directly, like
g_tree_foreach, that expects a GTraverseFunc.  In order to do this, a
<i>closure</i> is required.  In case you're unfamiliar with this term,
simply put this is a prepared function call, i.e. the function with some
or all arguments.</p>

<p>
In this case a C function that can call a Lua function
is used (see src/closure.c:closure_handler).  It prepares the call to the
Lua function, which is described in its argument "userdata", by converting
the arguments to Lua values.  The Lua function is called, its return value
(if any) is converted again and returned to the caller.
</p>


<h3>Automatic Closures</h3>

<p>
A simple example is this:
</p>

<div class="code"><code>
 sel = tree_view:get_selection()
 sel:selected_foreach(function(model, path, iter, data)
   print(model:get_value(iter, 0))
 end, nil)
</code></div>

<p>
In the above code snippet, the <tt>gtk_tree_selection_selected_foreach</tt>
function calls the given function once for each selected row.
Before lua-gtk calls the <tt>..._foreach</tt> function, a closure is
created for the given function, and after the call returns, it is
dereferenced and will eventually be garbage collected.
</p>

<h3>Explicit Closures</h3>

<p>
If the function can be called later, the closure must not be freed.  To
ensure that, you have to create a closure manually, store it in a variable,
and not unset the variable until the closure is no longer needed.
</p>

<div class="code"><code>
function compare_func(a, b)
    a = a.value
    b = b.value
    if a == b then return 0 end
    return a < b and -1 or 1
end

-- WRONG
t = g_tree_new(compare_func)

-- CORRECT
compare_func_closure = gtk.closure(compare_func)
t = g_tree_new(compare_func_closure)
</code></div>

<p>
As you can see, a g_tree requires a comparison function, to order all nodes.
It will call this function (at least) every time you insert more data.
Therefore, it won't do to provide a Lua function, because the closure
created for it will be freed (or could, as soon as garbage collection runs)
too soon.  To keep such closures around, you could store them in the
object itself:
</p>

<div class="code"><code>
  local closure = gtk.closure(compare_func)
  t = gtk.g_tree_new(closure)
  t._compare_closure = closure
</code></div>

<p>
This way, you won't have to worry about keeping the closure variable
around.  <b>Note:</b> unless you configured lua-gtk with --disable-debug,
it tries hard to detect cases when an automatic closure is given but won't
work.  You'll receive a runtime error.
</p>


