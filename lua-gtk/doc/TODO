
TODO
----

- support another hashing method of cmph: bdz.  Lookup seems a bit more
  code, though.
  there are _ph variants, which are perfect hashes, but not minimal, i.e.
  there are gaps in the resulting hash values, which causes unused buckets
  and therefore space wastage.
  
  for bdz_ph and the function list, 5710 keys map to 7139 buckets, wasting
  1429 buckets, which (at 2 bytes per bucket) means 2858 wasted bytes.
  for this size, the hash data is (on disk) 1826 bytes.

  the same with bdz, the data size is 2059, only slightly more, but now
  no buckets are wasted.  some additional code is required though.

  compare that to fch: much longer generation time, but data size is 4468
  bytes.

	- improve hash-fch-generate.c to also support bdz
	- write hash-bdz.c to support lookup with the bdz algorithm.


- socket_co: connect attempts must be asynchronous, otherwise the GUI can be
  blocked (by a slow DNS server, for example).
  	see libc-ares1

- review all the code for improvements and maybe some bugs

- GdkAtom represented in the function list with one level of indirection too
  many?  Like, GdkAtom* should be GdkAtom etc.  This is because GdkAtom is
  defined to be a pointer to the opaque _GdkAtom structure.

- wrapper for gtk_tree_model_get would be nice.

- add more #defines from the Gtk includes to the ENUM list automatically.
	gdk/gdkkeysyms.h
	gdk/gdkselection.h

- mingw port:
	- test it, users report that it's broken

- check refcounting usage, memory leaks
	- valgrind
	- glib memory statistics
	- make sure my reference counting (g_object_ref/_unref) is correct.
	  seems to be ok...
	- refcounting on GIOChannel not OK.  Sometimes in-use channels are
	  freed, which aborts communication. (probably already fixed)
	- GObject documentation on memory management says that when an object
	  is destroyed, the "dispose" handler should release all references
	  it might hold, while finalize really frees the object.  Does this
	  apply to lua-gtk?  Usually GObjects will have just one ref from
	  Lua, while the Lua proxy object may have multiple references.

- more documentation
	- improve the homepage, add more content, better layout
	- use luadoc tags for all user visible functions in the C modules
	- developer documentation to give pointers for hacking

- call tracing should show the actual values of the arguments; would require
  a new callback for each parameter type, some kind of tostring.

- running Win executables with wine under Linux, and using glade.lua - font
  sizes are insanely large.

- add support for Cairo
  http://cairographics.org/

- try LuaJIT - should speed everything up.  at least check that it works with
  it because in a larger project, somebody might want to use it.

