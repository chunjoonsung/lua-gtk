/** vim:sw=4:sts=4
 * In-memory representation of an MPH data file containing FCH data, as
 * generated by the utility cmph.  I don't want external files, so this MPH
 * data file (representation of the minimal perfect hash function) is stored
 * in these structures and compiled in.
 *
 * In addition to the hash function, which maps keys to bucket numbers,
 * actual data is included too.  This data the 32 bit hash value (to
 * identify hits and misses) and zero or more bytes of user defined data.
 */

struct my_hash_state {
    int hashfunc;		// which cmph hash functions
    int seed;			// as read from data file - only for jenkins
};

struct my_fch {
    unsigned int m, b;		// m=number of buckets
    unsigned int g_size;	// 16 or 32
    unsigned int p1, p2;	// magic parameters
    struct my_hash_state h1, h2;
    unsigned short g[];		// 16 or 32 bit entries
};

/**
 * One bucket per entry.  Note that due to the MPH hash function, there
 * are no empty buckets and no overflows.  The hash value is required to
 * verify a hit or miss; the MPH function returns a valid bucket for
 * any key!
 */
struct hash_bucket {
    unsigned int hash_value;
    unsigned int data_offset;	/* 16 or 32 bit entries */
};
#define BUCKET_SIZE(hi) (sizeof(unsigned int) + (hi)->offset_size)


struct hash_info {
    const struct my_fch *hash_func;	// data to calculate the bucket nr
    const void *index;			// array of hash_bucket
    const unsigned char *data;
    int offset_size;			// bytes per hash_bucket.data_offset
};


/* in hash-fch.c */
unsigned int my_fch_hash(const struct my_fch *fch, const char *key,
    int keylen, unsigned int *hash_value);
const unsigned char *hash_search(const struct hash_info *hi,
    const char *key, int keylen, int *datalen);


