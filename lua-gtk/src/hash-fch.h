/**
 * In-memory representation of an MPH data file containing FCH data, as
 * generated by the utility cmph.  I don't want external files, so this MPH
 * data file (representation of the minimal perfect hash function) is stored
 * in these structures and compiled in.
 *
 * In addition to the hash function, which maps keys to bucket numbers,
 * actual data is included too.  This data the 32 bit hash value (to
 * identify hits and misses) and zero or more bytes of user defined data.
 */

struct my_hash_state {
	int hashfunc;		/* all cmph hash functions are supported */
	int seed;		/* as read from data file - only for jenkins */
};

struct my_fch {
    int m, b;
    int g_size;			/* 16 or 32 */
    float p1, p2;		/* could be ints, too */
    struct my_hash_state h1, h2;
    unsigned short g[];		/* 16 or 32 bit entries */
};

/**
 * One bucket per entry.  Note that due to the MPH hash function, there
 * are no empty buckets and no overflows.  The hash value is required to
 * verify a hit or miss; the MPH function returns a valid bucket for
 * any key!
 */
struct hash_bucket {
    unsigned int hash_value;
    unsigned int data_offset;	/* 16 or 32 bit entries */
};


struct hash_info {
    const struct my_fch *hash_func;	/* data to calculate the bucket nr */
    const unsigned char *data_table;
    const void *hash_table;	/* sequence of my_hash_entries (buckets) */
    int offset_size;		/* bits per entry in hash_table */
};


/* in hash-fch.c */
unsigned int my_fch_hash(const struct my_fch *fch, const char *key,
    int keylen, unsigned int *hash_value);
const unsigned char *hash_search(const struct hash_info *hi,
    const char *key, int keylen, int *datalen);


